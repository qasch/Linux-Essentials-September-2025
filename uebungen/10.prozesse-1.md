# Prozesse

## Übung 1: Prozesse anzeigen
- Zeige die laufenden Prozesse in der aktuellen Shell an. 
- Verwende dazu `ps` ohne Optionen
- Starte anschließend eine weitere Shell mit dem Kommando `bash`. 
- Führe das Kommando `ps` erneut aus. Welches ist die *Eltern-* und welches die *Kind-* Shell? Woran kann man das erkennen?

## Übung 2: Alle Prozesse anzeigen
Zeige **alle** laufenden Prozesse auf deinem System an.
- Verwende `ps aux` um alle Prozesse zu sehen
- Nutze `ps -ef` für eine andere Darstellung
- Was ist der Unterschied? Vielleicht hilft es, dir hier die Spaltennamen anzeigen zu lassen. Versuche es mit einer Pipe und `head`.
- Probiere `pstree` für eine Baumansicht (dazu musst du ggf. das Paket `psmisc` installieren)

## Übung 3: Prozesse nach Ressourcenverbrauch sortieren
Finde die Prozesse, die am meisten CPU und RAM verbrauchen.
- Starte `top`
- Sortiere nach CPU-Verbrauch (Taste 'P' (großes 'P') in `top`)
- Sortiere nach RAM-Verbrauch (Taste 'M' (großes 'M') in `top`)

## Übung 4: Prozess in den Hintergrund schicken
Starte einen Prozess, der lange läuft, z.B. mit `sleep`:
```bash
sleep 300
```
> [!NOTE]
> Das Kommando `sleep` macht einfach gar nichts für die Anzahl der Sekunden, die wir angeben. Wird z.B. in Skripten benutzt um ein wenig zu warten, dass eine bestimmte Aufgabe erfüllt wurde.

Du kannst nun keine Kommandos mehr ausführen, da du in einer Shell nur einen einzelnen Prozess im **Vordergrund** ausführen kannst. Du hast nun entweder die Möglichkeit, diesen Prozess zu beenden, oder ihn in den Hintergrund zu schicken. Wir probieren letzteres:
- Drücke die Tastenkombination `STRG z`
- Du kannst wieder Eingaben machen, yeah! Aber was ist mit dem Prozess passiert? Du solltest eine Ausgabe sehen wie:
```bash
[1]+  Stopped                 sleep 300
```
Der Prozess wurde in den Hintergrund geschickt **und** angehalten/gestoppt. Du kannst dir mit dem Kommando `jobs` alle sich im Hintergrund befindlichen Prozesse und deren Status anzeigen lassen.

Hole den Prozess nun mit dem Kommando `fg` wieder **in den Vordergrund** und starte ihn damit gleichzeit wieder.

Nutze erneut `STRG z` um den Prozess in den Hintergrund zu schicken (starte ggf. einen neuen), gib dann `bg` ein um den Prozess **im Hintergrund fortzusetzen** und prüfe das Ergebnis mit `jobs`

## Übung 5 Unterschied `jobs` und `ps`
Informiere dich generell über die Kommandos `ps` und `jobs`. Was ist der Unterschied? Warum hat `jobs` keine Manpage? Probiere einmal `help jobs` oder suche in der Manpage der `bash` nach `JOB CONTROL`.

## Übung 6: Prozess im Hintergrund starten
Wir können Prozesse auch direkt nach dem Start in den Hintergrund schicken und starten, in dem wir ein `&` ans Ende der Eingabe setzen:
```bash
sleep 300 &
```
- Liste alle Background-Jobs mit `jobs`
- Bringe nun `ping` wieder in den Vordergrund mit `fg`. Dazu musst du `fg` den Index von `ping` übergeben

> [!NOTE]
> Wir das Zeichen `&` ja schon von den Redirects zur Angabe einer Kanalnummer bzw. Filedescriptors. In diesem Fall hat es jedoch eine andere Bedeutung, es ist ein Shell-Operator, der das Kommando im Hintergrund ausführt. Es gibt hier keinen Zusammenhang, genauso wie das `*` in der Shell einmal eine Wildcard ist und in der Mathematik das Zeichen für die Multiplikation.

## Übung 7: Ping ausser Rand und Band

Starte das Kommando `ping google.com &`, so dass es im Hintergrund ausgeführt wird. 

Blöderweise siehst du jetzt trotzdem die Meldungen von `ping`, dass `google.com` erreichbar ist, deine Shell wird fortlaufend zugemüllt. Kannst du noch Eingaben machen? Versuche den Prozess nun mit `STRG c` zu beenden. Das klappt aber nicht. Warum nur?

1. Mach dir Gedanken, warum das so ist. Der Prozess ist doch in den Hintergrund geschickt worden, die Meldungen erscheinen aber immer noch (im Vordergrund). Du kannst dir das erklären, wir haben in einem anderen Zusammenhang schon darüber gesprochen. Kleiner Tipp: Denke einmal daran, was generell mit jedem Prozess passiert, der gestartet wird...

2. Versuche nun, diesen Prozess aus einem anderen Terminal heraus zu beenden. 

Dafür musst du mit `kill` ein bestimmtes Signal an diesen Prozess senden. `kill` akzeptiert aber nur PIDs und keine Kommandos als Argument.

- Verwende `ps -ef` um dir alle laufenden Prozesse anzuzeigen, eine Pipe und das Kommando `grep`  um die PID von `ping` zu ermitteln
- Beende nun den Prozess mit `kill` und der Angabe seiner PID
- Hast du jetzt die Kontrolle über deine Shell zurück? 

## Übung 8: Signale mit kill an Prozesse senden
- Informiere dich in der Manpage von `kill`, welches Signal genau in Übung 7 an `ping` gesendet wurde, also welches Signal `kill` standardmässig versendet
- Schau dir einmal die Liste aller Signale mit dem Kommando `kill -l` an. Wichtig sind vielleicht folgende Signale:
  - `1) SIGHUP`
  - `2) SIGINT`
  - `3) SIGQUIT`
  - `9) SIGKILL`
  - `15) SIGTERM`
  - `18) SIGCONT`
  - `19) SIGSTOP`

Starte nun einen neuen Prozess `sleep 666` und schicke ihn in den Hintergrund mit `STRG z`. Prüfe den Status mit `jobs`. Der Prozess ist angehalten. 

1. Versuche nun, diesen Prozess mit dem Kommando `kill` und dem entsprechenden Signal **aus einem anderen Terminal heraus** im Hintergrund wieder auszuführen bzw. fortzusetzen. Prüfe das ganze mit `jobs`.
2. Halte den Prozess nun an. Auch wieder mit `kill` und dem entsprechenden Signal aus dem anderen Terminal heraus
3. Brich den Prozess nun hart ab - töte ihn!
4. Informiere dich über den Unterschied von z.B. `SIGTERM` und `SIGINT` zu `SIGKILL`.
5. Mit `kill` können Signale auf mehrere Arten gesendet werden: Über die Angabe der Signalnummer, des Signalnamens, Langoption, Kurzoption etc. Wie viele verschiedene Möglichkeiten findest du?

## Übung 7: pkill und pgrep
Starte drei `sleep 1000 &` Prozesse im Hintergrund.

Nutze nun das Kommando `pkill`, welchem nicht eine PID, sondern ein Name bzw. Pattern übergeben werden kann. Was passiert, wenn du `pkill sleep` ausführst?

Informiere dich auch über `pgrep`. Wiederhole dazu vielleicht das Beispiel mit `ping` aus Übung 6. Könnte `pgrep` hier nützlich sein? Und vielleicht auch `pkill`?

## Übung 8: Abhängigkeit von Prozessen

Starte in einer Shell ein beliebiges Kommando, welches länger läuft (`ping`, `sleep`). Ermittle dann aus einem anderen Terminal heraus die PID der Shell, in welcher du dieses Kommando gestartet hast. Beende nun den Prozess dieser Shell. 

Was passiert mit dem Kommando, welches darin gestartet wurde? Könnte das in bestimmten Situationen Probleme verursachen? Denke vielleicht mal darüber nach, was passiert, wenn du z.B. über `ssh` ein Upgrade eines System durchführst und dabei die SSH Verbindung abbricht...

Informiere dich in diesem Zusammenhang über das Kommando `nohup` und Terminal Mutliplexer wie `screen`, `tmux`, `zellij` ...

Du könntest mal wieder einen Prozess wie `ping` über `nohup` starten der stellvertretend für einen Prozess steht der lange läuft, wie ein Upgrade, Kopiervorgang oder so. 
```bash
nohup ping google.de &
```
Drücke danach einmal die Enter-Taste um deinen Prompt zurück zu bekommen. Beende nun aus einem anderen Terminal heraus die Shell, in der `ping` gestartet wurde. 

Ist `ping` jetzt auch beendet worden? Suche danach mit `ps` und `grep` oder nutze direkt `pgrep`.

Was kannst du daraus über ein *Best Practice* bezüglich Systemupgrades über SSH schliessen?

## Übung 9: Prozess-Signale und Tastenkombinationen
Bestimmte Tastenkombinationen senden im Endeffekt nur Signale an den momentan aktiven Prozess. 

1. Versuche herauszufinden, welche Signale die Tastenkombinationen `STRG z` und `STRG c` senden.
2. Versuche, anstatt der Tastenkombination das entsprechende Signal mit `kill` an einen Prozess zu senden.
3. Es gibt auch die Tastenkombination `STRG d`. Diese beendet z.B. eine laufende Eingabe. Sendet diese Tastenkombination auch ein Signal?

